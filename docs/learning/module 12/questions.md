# Module 12 – Interview Questions (Software Engineering & Design)

> Scope: **Middle+ → Senior / Lead**
> Focus: object-oriented design, design principles, responsibility assignment, and classic design patterns **with real-world trade-offs**.

> Assumption: candidate writes production code and has refactored non-trivial systems.

---

## Software Engineering – Fundamentals

1. What does “good software design” mean to you?
2. How do you evaluate code quality beyond “it works”?
3. What is technical debt and when is it acceptable?
4. How does design impact maintainability and team velocity?
5. What design mistakes are hardest to fix later?

---

## Object-Oriented Design (OOD)

### Core Concepts

1. What is object-oriented design?
2. Objects vs data structures — what’s the difference?
3. Encapsulation — what problem does it solve?
4. Abstraction vs implementation — why is this separation important?
5. Inheritance vs composition — when is each appropriate?
6. What does “designing for change” mean?

---

### Practical OOD

1. How do you identify classes and responsibilities?
2. What signals indicate that a class has too many responsibilities?
3. How do you avoid “God objects”?
4. How do you refactor procedural code into OOD?
5. How do you model behavior vs data?

---

## SOLID Principles

### Single Responsibility Principle (SRP)

1. What does SRP really mean?
2. What is a “reason to change”?
3. Give an example of SRP violation from real code.

---

### Open/Closed Principle (OCP)

1. What does it mean for software to be open for extension but closed for modification?
2. How do abstractions help with OCP?
3. How can OCP be over-applied?

---

### Liskov Substitution Principle (LSP)

1. What does LSP guarantee?
2. Give an example of LSP violation.
3. Why are runtime checks in subclasses often a smell?

---

### Interface Segregation Principle (ISP)

1. What problem does ISP solve?
2. Fat interfaces vs small interfaces — trade-offs.
3. How does ISP relate to API design?

---

### Dependency Inversion Principle (DIP)

1. What does dependency inversion mean?
2. How is DIP different from dependency injection?
3. How does DIP improve testability?
4. When does DIP add unnecessary complexity?

---

## GRASP Principles

### Responsibility Assignment

1. What is GRASP?
2. Why are GRASP principles useful in practice?

---

### Core GRASP Patterns

1. Information Expert — how do you identify it?
2. Creator — when should one class create another?
3. Controller — what is its responsibility and what it should *not* do?
4. Low Coupling — how do you measure it?
5. High Cohesion — why is it critical?
6. Indirection — when is it useful?
7. Pure Fabrication — when does it make sense?

---

## GoF Design Patterns

### Creational Patterns

1. Factory Method vs Abstract Factory.
2. Builder — what problem does it solve?
3. Singleton — why is it controversial?
4. When is a factory better than a constructor?

---

### Structural Patterns

1. Adapter — when do you need it?
2. Decorator vs inheritance.
3. Facade — how does it reduce complexity?
4. Proxy — use cases in real systems.

---

### Behavioral Patterns

1. Strategy — how does it enable OCP?
2. Observer — pros and cons.
3. Command — when is it useful?
4. State vs Strategy — how do you choose?
5. Template Method — when is it dangerous?

---

## Patterns in Practice

1. How do SOLID and GoF patterns work together?
2. When do patterns become anti-patterns?
3. How do you recognize over-engineering?
4. Have you removed a pattern from code? Why?

---

## Senior / Lead Level Discussion

1. What design principle do you see violated most often?
2. Which SOLID principle is hardest to apply correctly?
3. How do you teach design principles to less experienced developers?
4. How do you balance pragmatism vs purity in design?
5. What was the most complex refactoring you led?

---

> ✅ This file can be used as:
>
> * Software Engineering interview question bank
> * Senior / Lead readiness assessment
> * Design mentoring discussion guide
